(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(["exports"], factory);
  } else if (typeof exports !== "undefined") {
    factory(exports);
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports);
    global.singleSpaVue = mod.exports;
  }
})(this, function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports["default"] = singleSpaVue;

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

  var defaultOpts = {
    // required opts
    Vue: null,
    appOptions: null,
    template: null
  };

  function singleSpaVue(userOpts) {
    if (_typeof(userOpts) !== 'object') {
      throw new Error("single-spa-vue requires a configuration object");
    }

    var opts = _objectSpread({}, defaultOpts, {}, userOpts);

    if (!opts.Vue) {
      throw new Error('single-spa-vuejs must be passed opts.Vue');
    }

    if (!opts.appOptions) {
      throw new Error('single-spa-vuejs must be passed opts.appOptions');
    } // Just a shared object to store the mounted object state


    var mountedInstances = {};
    return {
      bootstrap: bootstrap.bind(null, opts, mountedInstances),
      mount: mount.bind(null, opts, mountedInstances),
      unmount: unmount.bind(null, opts, mountedInstances),
      update: update.bind(null, opts, mountedInstances)
    };
  }

  function bootstrap(opts) {
    if (opts.loadRootComponent) {
      return opts.loadRootComponent().then(function (root) {
        return opts.rootComponent = root;
      });
    } else {
      return Promise.resolve();
    }
  }

  function mount(opts, mountedInstances, props) {
    return Promise.resolve().then(function () {
      var appOptions = _objectSpread({}, opts.appOptions);

      if (props.domElement && !appOptions.el) {
        appOptions.el = props.domElement;
      }

      if (!appOptions.el) {
        var htmlId = "single-spa-application:".concat(props.name);
        appOptions.el = "#".concat(htmlId.replace(':', '\\:'), " .single-spa-container");
        var domEl = document.getElementById(htmlId);

        if (!domEl) {
          domEl = document.createElement('div');
          domEl.id = htmlId;
          document.body.appendChild(domEl);
        } // single-spa-vue@>=2 always REPLACES the `el` instead of appending to it.
        // We want domEl to stick around and not be replaced. So we tell Vue to mount
        // into a container div inside of the main domEl


        if (!domEl.querySelector('.single-spa-container')) {
          var singleSpaContainer = document.createElement('div');
          singleSpaContainer.className = 'single-spa-container';
          domEl.appendChild(singleSpaContainer);
        }

        mountedInstances.domEl = domEl;
      }

      if (!appOptions.render && !appOptions.template && opts.rootComponent) {
        appOptions.render = function (h) {
          return h(opts.rootComponent);
        };
      }

      if (!appOptions.data) {
        appOptions.data = {};
      }

      appOptions.data = _objectSpread({}, appOptions.data, {}, props);
      mountedInstances.instance = new opts.Vue(appOptions);

      if (mountedInstances.instance.bind) {
        mountedInstances.instance = mountedInstances.instance.bind(mountedInstances.instance);
      }
    });
  }

  function update(opts, mountedInstances, props) {
    return Promise.resolve().then(function () {
      var data = _objectSpread({}, opts.appOptions.data || {}, {}, props);

      for (var prop in data) {
        mountedInstances.instance[prop] = data[prop];
      }
    });
  }

  function unmount(opts, mountedInstances) {
    return Promise.resolve().then(function () {
      mountedInstances.instance.$destroy();
      mountedInstances.instance.$el.innerHTML = '';
      delete mountedInstances.instance;

      if (mountedInstances.domEl) {
        mountedInstances.domEl.innerHTML = '';
        delete mountedInstances.domEl;
      }
    });
  }
});
//# sourceMappingURL=single-spa-vue.js.map