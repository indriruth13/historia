(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define("Parcel", ["exports", "react", "../lib/single-spa-react.js"], factory);
  } else if (typeof exports !== "undefined") {
    factory(exports, require("react"), require("../lib/single-spa-react.js"));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports, global.React, global.singleSpaReact);
    global.Parcel = mod.exports;
  }
})(this, function (_exports, _react, _singleSpaReact) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports["default"] = void 0;
  _react = _interopRequireDefault(_react);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  var Parcel =
  /*#__PURE__*/
  function (_React$Component) {
    _inherits(Parcel, _React$Component);

    function Parcel(props) {
      var _this;

      _classCallCheck(this, Parcel);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Parcel).call(this, props));

      _defineProperty(_assertThisInitialized(_this), "handleRef", function (el) {
        _this.el = el;
      });

      _defineProperty(_assertThisInitialized(_this), "addThingToDo", function (action, thing) {
        if (_this.state.hasError && action !== 'unmount') {
          // In an error state, we don't do anything anymore except for unmounting
          return;
        }

        _this.nextThingToDo = (_this.nextThingToDo || Promise.resolve()).then(function () {
          if (_this.unmounted && action !== 'unmount') {
            // Never do anything once the react component unmounts
            return;
          }

          return thing.apply(void 0, arguments);
        })["catch"](function (err) {
          _this.nextThingToDo = Promise.resolve(); // reset so we don't .then() the bad promise again

          _this.setState({
            hasError: true
          });

          if (err && err.message) {
            err.message = "During '".concat(action, "', parcel threw an error: ").concat(err.message);
          }

          if (_this.props.handleError) {
            _this.props.handleError(err);
          } else {
            setTimeout(function () {
              throw err;
            });
          } // No more things to do should be done -- the parcel is in an error state


          throw err;
        });
      });

      _defineProperty(_assertThisInitialized(_this), "getParcelProps", function () {
        var parcelProps = _objectSpread({}, _this.props);

        delete parcelProps.mountParcel;
        delete parcelProps.config;
        delete parcelProps.wrapWith;
        delete parcelProps.appendTo;
        delete parcelProps.handleError;
        delete parcelProps.parcelDidMount;
        return parcelProps;
      });

      _this.state = {
        hasError: false
      };

      if (!props.config) {
        throw new Error("single-spa-react's Parcel component requires the 'config' prop to either be a parcel config or a loading function that returns a promise. See https://github.com/CanopyTax/single-spa-react");
      }

      return _this;
    }

    _createClass(Parcel, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        var _this2 = this;

        this.addThingToDo('mount', function () {
          var mountParcel = _this2.props.mountParcel || _this2.mountParcel;

          if (!mountParcel) {
            throw new Error("\n\t\t\t\t  <Parcel /> was not passed a mountParcel prop, nor is it rendered where mountParcel is within the React context.\n\t\t\t\t  If you are using <Parcel /> within a module that is not a single-spa application, you will need to import mountRootParcel from single-spa and pass it into <Parcel /> as a mountParcel prop\t\n\t\t\t\t");
          }

          var domElement;

          if (_this2.el) {
            domElement = _this2.el;
          } else {
            _this2.createdDomElement = domElement = document.createElement(_this2.props.wrapWith);

            _this2.props.appendTo.appendChild(domElement);
          }

          _this2.parcel = mountParcel(_this2.props.config, _objectSpread({
            domElement: domElement
          }, _this2.getParcelProps()));

          _this2.parcel.mountPromise.then(_this2.props.parcelDidMount);

          return _this2.parcel.mountPromise;
        });
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate() {
        var _this3 = this;

        this.addThingToDo('update', function () {
          if (_this3.parcel && _this3.parcel.update) {
            return _this3.parcel.update(_this3.getParcelProps());
          }
        });
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        var _this4 = this;

        this.addThingToDo('unmount', function () {
          if (_this4.parcel && _this4.parcel.getStatus() === "MOUNTED") {
            return _this4.parcel.unmount();
          }
        });

        if (this.createdDomElement) {
          this.createdDomElement.parentNode.removeChild(this.createdDomElement);
        }

        this.unmounted = true;
      }
    }, {
      key: "render",
      value: function render() {
        var _this5 = this;

        if (this.props.appendTo) {
          if (_singleSpaReact.SingleSpaContext && _singleSpaReact.SingleSpaContext.Consumer) {
            return _react["default"].createElement(_singleSpaReact.SingleSpaContext.Consumer, null, function (context) {
              _this5.mountParcel = context ? context.mountParcel : null;
              return null;
            });
          } else {
            return null;
          }
        } else {
          var children = _singleSpaReact.SingleSpaContext && _singleSpaReact.SingleSpaContext.Consumer ? _react["default"].createElement(_singleSpaReact.SingleSpaContext.Consumer, null, function (context) {
            _this5.mountParcel = context ? context.mountParcel : null;
            return null;
          }) : undefined;
          return _react["default"].createElement(this.props.wrapWith, {
            ref: this.handleRef
          }, children);
        }
      }
    }]);

    return Parcel;
  }(_react["default"].Component);

  _exports["default"] = Parcel;

  _defineProperty(Parcel, "defaultProps", {
    wrapWith: 'div',
    parcelDidMount: function parcelDidMount() {}
  });
});

//# sourceMappingURL=index.js.map