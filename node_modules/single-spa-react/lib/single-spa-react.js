(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(["exports"], factory);
  } else if (typeof exports !== "undefined") {
    factory(exports);
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports);
    global.singleSpaReact = mod.exports;
  }
})(this, function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports["default"] = singleSpaReact;
  _exports.SingleSpaContext = void 0;

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

  function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

  /* We don't import parcel.component.js from this file intentionally. See comment
   * in that file for why
   */
  // React context that gives any react component the single-spa props
  var SingleSpaContext = null;
  _exports.SingleSpaContext = SingleSpaContext;
  var defaultOpts = {
    // required opts
    React: null,
    ReactDOM: null,
    rootComponent: null,
    loadRootComponent: null,
    suppressComponentDidCatchWarning: false,
    // optional opts
    domElementGetter: null,
    parcelCanUpdate: true // by default, allow parcels created with single-spa-react to be updated

  };

  function singleSpaReact(userOpts) {
    if (_typeof(userOpts) !== 'object') {
      throw new Error("single-spa-react requires a configuration object");
    }

    var opts = _objectSpread({}, defaultOpts, userOpts);

    if (!opts.React) {
      throw new Error("single-spa-react must be passed opts.React");
    }

    if (!opts.ReactDOM) {
      throw new Error("single-spa-react must be passed opts.ReactDOM");
    }

    if (!opts.rootComponent && !opts.loadRootComponent) {
      throw new Error("single-spa-react must be passed opts.rootComponent or opts.loadRootComponent");
    }

    if (!SingleSpaContext && opts.React.createContext) {
      _exports.SingleSpaContext = SingleSpaContext = opts.React.createContext();
    }

    var lifecycles = {
      bootstrap: bootstrap.bind(null, opts),
      mount: mount.bind(null, opts),
      unmount: unmount.bind(null, opts)
    };

    if (opts.parcelCanUpdate) {
      lifecycles.update = update.bind(null, opts);
    }

    return lifecycles;
  }

  function bootstrap(opts, props) {
    if (opts.rootComponent) {
      // This is a class or stateless function component
      return Promise.resolve();
    } else {
      // They passed a promise that resolves with the react component. Wait for it to resolve before mounting
      return opts.loadRootComponent().then(function (resolvedComponent) {
        opts.rootComponent = resolvedComponent;
      });
    }
  }

  function mount(opts, props) {
    return new Promise(function (resolve, reject) {
      if (!opts.suppressComponentDidCatchWarning && atLeastReact16(opts.React)) {
        if (!opts.rootComponent.prototype) {
          console.warn("single-spa-react: ".concat(props.name || props.appName || props.childAppName, "'s rootComponent does not have a prototype.  If using a functional component, wrap it in an error boundary or other class that implements componentDidCatch to avoid accidentally unmounting the entire single-spa application"));
        } else if (!opts.rootComponent.prototype.componentDidCatch) {
          console.warn("single-spa-react: ".concat(props.name || props.appName || props.childAppName, "'s rootComponent should implement componentDidCatch to avoid accidentally unmounting the entire single-spa application."));
        }
      }

      var domElementGetter = chooseDomElementGetter(opts, props);

      if (typeof domElementGetter !== 'function') {
        throw new Error("single-spa-react: the domElementGetter for react application '".concat(props.appName || props.name, "' is not a function"));
      }

      var whenFinished = function whenFinished() {
        resolve(this);
      };

      var rootComponentElement = opts.React.createElement(opts.rootComponent, props);
      var elementToRender = SingleSpaContext ? opts.React.createElement(SingleSpaContext.Provider, {
        value: props
      }, rootComponentElement) : rootComponentElement;
      var domElement = getRootDomEl(domElementGetter, props);
      var renderedComponent = reactDomRender({
        elementToRender: elementToRender,
        domElement: domElement,
        whenFinished: whenFinished,
        opts: opts
      });
      opts.domElement = domElement;
    });
  }

  function unmount(opts, props) {
    return Promise.resolve().then(function () {
      opts.ReactDOM.unmountComponentAtNode(opts.domElement);
    });
  }

  function update(opts, props) {
    return new Promise(function (resolve, reject) {
      var whenFinished = function whenFinished() {
        resolve(this);
      };

      var rootComponentElement = opts.React.createElement(opts.rootComponent, props);
      var elementToRender = SingleSpaContext ? opts.React.createElement(SingleSpaContext.Provider, {
        value: props
      }, rootComponentElement) : rootComponentElement;
      var renderedComponent = reactDomRender({
        elementToRender: elementToRender,
        domElement: opts.domElement,
        whenFinished: whenFinished,
        opts: opts
      });
    });
  }

  function getRootDomEl(domElementGetter, props) {
    var el = domElementGetter();

    if (!el) {
      throw new Error("single-spa-react: domElementGetter function for application '".concat(props.appName || props.name, "' did not return a valid dom element. Please pass a valid domElement or domElementGetter via opts or props"));
    }

    return el;
  }

  function atLeastReact16(React) {
    if (React && typeof React.version === 'string' && React.version.indexOf('.') >= 0) {
      var majorVersionString = React.version.slice(0, React.version.indexOf('.'));

      try {
        return Number(majorVersionString) >= 16;
      } catch (err) {
        return false;
      }
    } else {
      return false;
    }
  }

  function chooseDomElementGetter(opts, props) {
    props = props && props.customProps ? props.customProps : props;

    if (props.domElement) {
      return function () {
        return props.domElement;
      };
    } else if (props.domElementGetter) {
      return props.domElementGetter;
    } else if (opts.domElementGetter) {
      return opts.domElementGetter;
    } else {
      return defaultDomElementGetter(props);
    }
  }

  function defaultDomElementGetter(props) {
    var htmlId = "single-spa-application:".concat(props.appName || props.name);

    if (!htmlId) {
      throw Error("single-spa-react was not given an application name as a prop, so it can't make a unique dom element container for the react application");
    }

    return function defaultDomEl() {
      var domElement = document.getElementById(htmlId);

      if (!domElement) {
        domElement = document.createElement('div');
        domElement.id = htmlId;
        document.body.appendChild(domElement);
      }

      return domElement;
    };
  }

  function reactDomRender(_ref) {
    var opts = _ref.opts,
        elementToRender = _ref.elementToRender,
        domElement = _ref.domElement,
        whenFinished = _ref.whenFinished;

    if (opts.renderType === 'createRoot') {
      return opts.ReactDOM.createRoot(domElement).render(elementToRender, whenFinished);
    }

    if (opts.renderType === 'hydrate') {
      return opts.ReactDOM.hydrate(elementToRender, domElement, whenFinished);
    } // default to this if 'renderType' is null or doesn't match the other options


    return opts.ReactDOM.render(elementToRender, domElement, whenFinished);
  }
});

//# sourceMappingURL=single-spa-react.js.map